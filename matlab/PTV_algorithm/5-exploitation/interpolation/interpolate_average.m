% This function interpolates a circle given a set of trajectories. For each
% trajectory of the set, the function interpolates a circle (using 
% interpolate_traj). Then it computes an average circle based on each 
% calculated circle.
%
% INPUTs: 
% tr = a set of trajectories
% set = a set of images 
% percent = a number in [0 100] corresponding to the minimum percentage of 
% images a trajectory must containt to be taken into account in the 
% calculation. If a trajectory of the set has a length inferior to 
% percent*nbImages/100, then the trajectory is ignored. 
%
% OUTPUTs:
% result = matrix containinig all the circles computed thanks to every
%          trajectories from tr. From the trajectory ID, the function
%          computes a circle stocked in result(i,:).
%          result(i,:) = [centerXi centerYi radius_i trajectory_ID]
% circle = [interior_centerX interior_centerY interior_radius]
%          It is the mean circle of all the circles of result 
% deltaX = standard-deviation of the centerX coordinate 
% deltaY = standard-deviation of the centerY coordinate
% deltaR = standard-deviation of the radius 

function [result, circle,deltaX,deltaY,deltaR] = interpolate_average(tr, set, percent)

result = [];
data_tracking = get_data_tracking(set, tr);

limit = floor(percent*data_tracking.nbImages/100);
index2 = 1;
for index = 1:data_tracking.nbImages+1-limit
    for i=1:data_tracking.dataTrajectories(index,2)

        traj_ID = data_tracking.dataTrajectories(index,2+i);

        j=1;
        while tr(j,4) ~= traj_ID
            j=j+1;
        end

        trajectory = tr(j:j+data_tracking.dataTrajectories(index,1)-1,:);
        result(index2,1:3) = interpolate_traj(trajectory);
        result(index2,4) = traj_ID;
        index2 = index2+1;

    end
    
end

deltaX = std(result(:,1));
deltaY = std(result(:,2));
deltaR = std(result(:,3));

%computing the mean circle
circle(1,:) = mean(result(:,:));

end