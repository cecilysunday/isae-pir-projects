%INPUTS:
%tr: a set of trajectories
%time: the timestep between 2 successive frames
%radius: the radius of the inner cylinder
%centerx: x-coordinate of the center of rotation
%centery: y-coordinate of the center of rotation
%angular_estimated: an estimation of the angular velocity
%error_plage: see the definition of I below
%limit:

%This function defines an interval I: 
%I = [w(1+error_plage/100)     w(1+error_plage/100)]
%Where w the estimated angular velocity.

%Then for each skipstep in [1 nbImages-1], this function computes an array 
%v_ang of angular velocities and computes the percentage of angular 
%velocities which are in the interval I.

%OUTPUT: an array 'result' of size nb_images * 5

%result(i,1) = number of angular velocities in I when computed using the
%              skipstep i
%result(i,1) = total number of angular velocities computed using the
%              skipstep i
%result(i,3) = percentage of angular velocities in I when the angular 
%              velocities are computed using the skipstep i.
%result(i,4) = the mean of all the angular velocities computed using the
%              skipstep i
%result(i,5) = the mean of all the angular velocities computed using the
%              skipstep i and witch are in I

function result = get_data_omega_skipstep(tr, data_tracking, time, radius, centerx, centery, angular_estimated, error_plage)

result = [];
index2 = 1;

skipstep = 1;
tr2 = compute_velocity(tr, time, centerx, centery, skipstep);
s_tr2 = size(tr2);

while (skipstep < data_tracking.nbImages) && (s_tr2(2) > 0)
    
    index = 0;
    v_ang = tr2(:,6)/radius;
    v_ang_moy = mean(v_ang);
    
    sz = size(v_ang);
    errorPlus = -angular_estimated*(1+error_plage/100);
    errorMoins = -angular_estimated*(1-error_plage/100);
    
    v_ang2 = [];
    for j=1:sz(1)
       if(-v_ang(j) >  errorMoins && -v_ang(j) <  errorPlus)
           index = index+1;
           v_ang2(index,1) = v_ang(j);
       end
    end
    v_ang2_moy = mean(v_ang2);
    
    result(index2,1) = index;
    result(index2,2) = sz(1);
    result(index2,3) = index/sz(1)*100;
    result(index2,4) = v_ang_moy;
    result(index2,5) = v_ang2_moy;
    
    index2=index2+1;
    skipstep = skipstep +1;
    tr2 = compute_velocity(tr, time, centerx, centery, skipstep);
    s_tr2 = size(tr2);

end

sz = size(result);
result(sz(1)+2,4) = mean(result(1:sz,4));
result(sz(1)+2,5) = mean(result(1:sz,5));


end